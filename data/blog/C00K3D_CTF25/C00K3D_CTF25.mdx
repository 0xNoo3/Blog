---
title: 'C00K3D CTF 25 Official Rev Writeups'
date: '2025-08-31'
tags: ['C00K3D CTF', 'RE', 'Writeups']
draft: false
summary: Will more focus on how challenge was made and the intended way to solve it, though there are many small tricks to solve the challenges as well for you to figure it out :)
---

## Table of Contents

- [Frustation](#frustation)
- [WarmUp](#warmup)
- [Lost](#lost)
- [The Chip8 Emulator](#the-chip8-emulator)

# Frustation

Chall Description:

![alt text](/static/images/cookedctf25/frustation/des.png)

## Code

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rdx
  _QWORD v5[6]; // [rsp+0h] [rbp-30h] BYREF

  v5[5] = __readfsqword(0x28u);
  puts("Exclude the flag format C00K3D{}\n\nEnter Secret ", argv, envp);
  if ( _isoc23_scanf("%32s", v5) == 1 )
  {
    checkValid(v5);
    return 0;
  }
  else
  {
    puts("No input.", v5, v3);
    return 1;
  }
}

```

main() reads the user input and passes to the checkValid() function as a param

```c
unsigned __int64 __fastcall checkValid(const char *a1)
{
  __int64 v1; // rdx
  unsigned __int64 i; // [rsp+18h] [rbp-38h]
  _BYTE v4[40]; // [rsp+20h] [rbp-30h] BYREF
  unsigned __int64 v5; // [rsp+48h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  for ( i = 0LL; i <= 0x20; ++i )
    v4[i] = KEY ^ *(&enc_data + i);
  if ( j_strcmp_ifunc(a1, v4) )
    puts("Wrong!", v4, v1);
  else
    printf("Correct: COOK3D{%s}", a1);
  return v5 - __readfsqword(0x28u);
}
```

So here it is clear that there is encoded data which is xored with a key, and then compared to the input pretty easy right?

```c
enc_data located at .data:00000000004CA100

unsigned char enc_data[] =
{
  0xFE, 0xC2, 0xC3, 0xD9, 0x9B, 0xD9, 0xFE, 0xC2, 0x99, 0xC3,
  0xC4, 0xC3, 0xDE, 0xC3, 0xCB, 0xDE, 0xC3, 0xC5, 0xC4, 0x9A,
  0xCC, 0xF5, 0xEC, 0xD8, 0xDF, 0xD9, 0xDE, 0xCB, 0xDE, 0xC3,
  0xC5, 0xC4, 0xAA
};

and KEY located at .data:00000000004CA0E0

KEY = 0xAA;

```

So when we XOR each byte of enc_data with the KEY it gives us

```
This1sTh3initiation0f_Frustation
```

But when we put it as a password it gives wrong message

```bash

$ ./frustation
Exclude the flag format C00K3D{}

Enter Secret
This1sTh3initiation0f_Frustation
Wrong!

```

What !!! maybe we should check whats happening in the debugger, the binary is changing its behavior?

```bash

gef➤  r
Starting program: /mnt/e/Cooked CTF/Finals/Frustation/frustation
Exclude the flag format C00K3D{}

Enter Secret
This1sTh3initiation0f_Frustation
Correct: COOK3D{This1sTh3initiation0f_Frustation}[Inferior 1 (process 583) exited normally]
gef➤

```

Gives us that the flag is Correct !
So its very clear, that the binary is changing the behavior when the debugger is attached or vice versa.
But this can only be possible if there is a ptrace implementation in the binary, but we clearly didnt saw
any ptrace implementation in the main() or check() func.

So here our knowledge will come into play :) (yes you can solve it directly by jumping)

![alt text](/static/images/cookedctf25/frustation/premain.png)

There are alot things/functions which are initiated pre main()
the function

```c

unsigned __int64 do_global_ctors_aux()

```

This is the important, Question arises how do we know that, You can check the .init_array to make things easier for yourself.

```c
__attribute__((constructor))
```

the programmer can mark it on any custom function.
and all those will be pointed by the .init_array, but for this challenge it is very obvious you can just search `ctors`

```c

unsigned __int64 do_global_ctors_aux()
{
  int v0; // r9d
  unsigned __int64 v2; // [rsp+38h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  *(_DWORD *)_errno_location() = 0;
  if ( syscall(101, 0, 0, 0, 0, v0) != -1 )
  {
    enc_data = 0xDDF5C4C7CBEEC2CBLL;
    qword_4CA108 = 0xDD9AC4C1ECFEC5C2LL;
    qword_4CA110 = 0xC3F5D2DFC49BE6D9LL;
    qword_4CA118 = 0xF9C6CBC4D899FEC4LL;
    byte_4CA120 = -86;
  }
  return v2 - __readfsqword(0x28u);
}

```

here you can see the syscall which is basically a ptrace checks if there is not a debugger than will load the orginal bytes of the flag, other wise fake flag is loaded in the
check()

So just replace the enc_data with these values and the KEY is 0xAA and you get the Secret
`ahDamn_whoTFkn0wsL1nux_inT3rnalS`

thats all lol, it is not tbh exactly linux internals more of a C programming thing put it looks cool xD

```bash
$ ./frustation
Exclude the flag format C00K3D{}

Enter Secret
ahDamn_whoTFkn0wsL1nux_inT3rnalS
Correct: COOK3D{ahDamn_whoTFkn0wsL1nux_inT3rnalS}
```

This is the correct flag :)

# WarmUp

Chall Description:

![alt text](/static/images/cookedctf25/frustation/des2.png)

So this was a classic password checker GUI, so the first step is to locate the WinMain function, which you can find easily if you have saw the writeup of demo's rev/GUI Licence checker
inside the Winmain we can see this function.

## Code

```cpp

__int64 __fastcall sub_140001A62(HINSTANCE a1)
{
  MSG Msg; // [rsp+60h] [rbp-80h] BYREF
  WNDCLASSW WndClass; // [rsp+90h] [rbp-50h] BYREF

  *(_QWORD *)&WndClass.style = 0LL;
  *(_QWORD *)&WndClass.cbClsExtra = 0LL;
  WndClass.hIcon = 0LL;
  WndClass.lpszMenuName = 0LL;
  WndClass.hbrBackground = (HBRUSH)5;
  WndClass.hCursor = LoadCursorA(0LL, (LPCSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.lpszClassName = "C";
  WndClass.lpfnWndProc = (WNDPROC)sub_140001724;
  if ( !RegisterClassW(&WndClass) )
    return 0xFFFFFFFFLL;
  CreateWindowExW(0, "C", L"WarmUp by Cooked CTF", 0x10CF0000u, 100, 70, 500, 200, 0LL, 0LL, 0LL, 0LL);
  memset(&Msg, 0, sizeof(Msg));
  while ( GetMessageA(&Msg, 0LL, 0, 0) )
  {
    TranslateMessage(&Msg);
    DispatchMessageA(&Msg);
  }
  return 0LL;
}
```

We are concerned about this `  WndClass.lpfnWndProc = (WNDPROC)sub_140001724;`

In that function i can see that `sub_1400015E7` is resposible for validation

```cpp
    {
      GetWindowTextW(hWnd, String, 100);
      v6 = sub_1400019AD(String);
      if ( (unsigned int)sub_1400015E7(v6) )
        MessageBoxW(0LL, L"Wrong Password", L"Error", 0);
      else
        MessageBoxW(0LL, L"Submit the flag as C00K3D{key_you_entered}", "C", 0);
    }
```

I have renamed the function name so that it maybe clear what they are doing

```cpp

_BOOL8 __fastcall sub_1400015E7(const char *input)
{
  _DWORD buffer[4000]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v3[3]; // [rsp+3EA0h] [rbp+3E20h] BYREF
  int v4; // [rsp+3EBCh] [rbp+3E3Ch]
  int v5; // [rsp+3EC0h] [rbp+3E40h]
  int v6; // [rsp+3EC4h] [rbp+3E44h]
  int v7; // [rsp+3EC8h] [rbp+3E48h]
  int v8; // [rsp+3ECCh] [rbp+3E4Ch]
  size_t v9; // [rsp+3ED0h] [rbp+3E50h]
  int v10; // [rsp+3EDCh] [rbp+3E5Ch]

  v9 = strlen(input);
  v10 = 1;
  if ( v9 != 8 )
    return 1LL;
  v3[0] = 0LL;
  v3[1] = 0LL;
  str_to_hex(input, v3);
  v8 = *(v3 + 1);
  v7 = HIBYTE(*(v3 + 1));
  v6 = BYTE3(v3[0]);
  v5 = BYTE2(v3[0]);
  v4 = BYTE1(v3[0]);
  number_seq_gen(4000, buffer);
  return v7 != buffer[367] || v6 != buffer[377] || v5 != buffer[389] || v4 != buffer[385];
}

```

So it is basically converting our string to hex, and generating a number sequence in the buffer of 4000 bytes.

```cpp
__int64 __fastcall number_seq_gen(int hardcoded4k, _DWORD *buffer)
{
  __int64 result; // rax
  int j; // [rsp+4h] [rbp-Ch]
  int v4; // [rsp+8h] [rbp-8h]
  int i; // [rsp+Ch] [rbp-4h]

  *buffer = 0;
  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= hardcoded4k )
      break;
    v4 = buffer[i - 1] - i;
    for ( j = 0; j < i; ++j )
    {
      if ( v4 == buffer[j] || v4 < 0 )
      {
        v4 = buffer[i - 1] + i;
        break;
      }
    }
    buffer[i] = v4;
  }
  return result;
}
```

So basically you can reimplement it and check the buffer indexes `return v7 != buffer[367] || v6 != buffer[377] || v5 != buffer[389] || v4 != buffer[385];`

or you can simple but a breakpoint and check it dynamically the buffer indexes are you password.

# Lost

Chall Description:

![alt text](/static/images/cookedctf25/frustation/des3.png)

It was a Simgle 3d Godot game, and its assets were encrypted (AES 256), For that I recompiled the godot custom export template with a 32byte key as an env variable (https://docs.godotengine.org/en/4.4/contributing/development/compiling/compiling_with_script_encryption_key.html),
This is done so that when ever the game is exported its assets will be decrypted at runtime so the game assets cannot be stolen, but obviously the godot engine has to place
that AES Key somewhere statically in the binary right? So it is done by default by the Godot engine, the key is placed as a byte array of 32byte just bellow a string `fae.is_null` something like that
just search for the string and extract the aes 32 byte key and yes it can take alot of time to decompile. Enter the key in the godot decompiler.

perhaps watch this video its like 10 times better than my writeup :
https://www.youtube.com/watch?v=fWjuFmYGoSY&t=53s&ab_channel=Giffi

# The Chip8 Emulator

Chall Description:

![alt text](/static/images/cookedctf25/frustation/des4.png)

During the event the binary was stripped because i had currupted the the e_shnum located at offset 0x3c in x64 ELF and e_shstrndx at offset 0x3e So that gdb-gef will not even recognize
it as a correct ELF Format, So during this the symbols were also complely lost. I can obviously make a writeup of the unstripped version but that wont be fun for you guys tbh. I have given the unstripped binary in our discord server for you to check it out : )

So first, we need to have a little idea how emulation works, It fetched instruction of a program and emulate the behavior of the target hardware.
So the chip8 emulator is the simplest known emulator (atleast to me) it fetches the opcodes from the rom file, and emulates 2bytes per cpu cycle.
For better understanding of chip8 emulator you can check this https://austinmorlan.com/posts/chip8_emulator/ So if you read this you will get what i am saying next :p

```cpp
// i have skipped a big chunk
      v17 = v6 ^ ((v25 | v17 | ((i1 | nn)
                              - (i1 & (((v25 | v23 | v23 ^ i1 ^ nn) - ((v25 | v23) ^ (v17 | v25) & (v23 ^ i1 ^ nn)) - 1) ^ ((v23 | i1 ^ nn) - (v23 ^ v17 & (i1 ^ nn)) - 1)) ^ nn)
                              - 1))
                - (((nn ^ i1 & (((v25 | v23 | v23 ^ i1 ^ nn) - ((v25 | v23) ^ (v17 | v25) & (v23 ^ i1 ^ nn)) - 1) ^ ((v23 | i1 ^ nn) - (v23 ^ v17 & (i1 ^ nn)) - 1)))
                  - (i1 | nn)) & (v25 | v17))
                - 1);

    v24 = ((((v17 << ((char)(7 * nn) % 29)) ^ (v17 >> ((char)(5 * nn) % 23)))
          + ((v17 >> ((char)(5 * nn) % 23)) | (v17 << ((char)(7 * nn) % 29)))) ^ ((~(v17 << ((char)(7 * nn) % 29)) | (v17 >> ((char)(5 * nn) % 23)))
                                                                                + ((v17 >> ((char)(5 * nn) % 23)) | (v17 << ((char)(7 * nn) % 29)))))
        + (((v23 | (v17 << ((char)(7 * nn) % 29))) - ((v17 << ((char)(7 * nn) % 29)) ^ v23 & nn) - 1) ^ ((v17 | (v17 << ((char)(7 * nn) % 29)) | v23 ^ (v17 << ((char)(7 * nn) % 29))) - ((v17 | (v17 << ((char)(7 * nn) % 29))) ^ (v17 | nn) & (v23 ^ (v17 << ((char)(7 * nn) % 29)))) - 1))
        - (v17 ^ (v17 >> ((char)(5 * nn) % 23)));
    v17 = 0;
    emu_key[nn] = charset[(unsigned __int8)(v24 >> (nn & 7)) % 0x3EuLL];

  byte_1B4A0 = 0;
```

Key was generated at runtime by MBA
This was being done in Emulator::init()

And from the description it is very clear that the bug is in vCPU, so lets see what the chip9 CPU exactly does !

```cpp

unsigned __int64 __fastcall Emulator::run(Emulator *this)
{
  std::chrono::_V2::system_clock *v1; // rdi
  __int64 v2; // rbx
  __int64 v3; // rax
  Emulator *v5; // [rsp+8h] [rbp-A8h]
  int v6; // [rsp+1Ch] [rbp-94h]
  __int64 v7; // [rsp+20h] [rbp-90h] BYREF
  __int64 v8; // [rsp+28h] [rbp-88h] BYREF
  __int64 v9; // [rsp+30h] [rbp-80h] BYREF
  _BYTE v10[8]; // [rsp+38h] [rbp-78h] BYREF
  __int64 v11; // [rsp+40h] [rbp-70h] BYREF
  __int64 v12; // [rsp+48h] [rbp-68h] BYREF
  _BYTE v13[32]; // [rsp+50h] [rbp-60h] BYREF
  _BYTE v14[40]; // [rsp+70h] [rbp-40h] BYREF
  unsigned __int64 v15; // [rsp+98h] [rbp-18h]

  v5 = this;
  v15 = __readfsqword(0x28u);
  v7 = 0LL;
  v8 = 0LL;
  v9 = 1LL;
  v6 = 0;
  while ( *(v5 + 6202) )  // true untill exited by the user :)
  {
    v7 = std::chrono::_V2::system_clock::now(this);
    Cpu::fetch(*v5); // fetching of opcodes from the chip8 ram
    Cpu::decode(*v5); // decoding it
    Cpu::execute(*v5); // Finally emulating it per instruction
    if ( v6 > 19 )
    {
      v6 = 0;
      (*(**(v5 + 779) + 8LL))(*(v5 + 779), v5 + 8, 64LL, 32LL);
      (*(**(v5 + 779) + 16LL))(*(v5 + 779));
      if ( *(v5 + 6200) )
        --*(v5 + 6200);
      if ( *(v5 + 6201) )
      {
        --*(v5 + 6201);
        (*(**(v5 + 781) + 8LL))(*(v5 + 781));
      }
      else
      {
        (*(**(v5 + 781) + 16LL))(*(v5 + 781));
      }
    }
    v1 = *(v5 + 780);
    (*(*v1 + 8LL))(v1, v5 + 2056, v5 + 6202);
    v8 = std::chrono::_V2::system_clock::now(v1);
    v12 = std::chrono::operator-<std::chrono::_V2::system_clock,std::chrono::duration<long,std::ratio<1l,1000000000l>>,std::chrono::duration<long,std::ratio<1l,1000000000l>>>(
            &v8,
            &v7);
    std::chrono::duration<double,std::ratio<1l,1000000l>>::duration<long,std::ratio<1l,1000000000l>,void>(v10, &v12);
    v12 = std::chrono::operator-<std::chrono::_V2::system_clock,std::chrono::duration<long,std::ratio<1l,1000000000l>>,std::chrono::duration<long,std::ratio<1l,1000000000l>>>(
            &v8,
            &v7);
    v11 = std::chrono::duration_cast<std::chrono::duration<long,std::ratio<1l,1000l>>,long,std::ratio<1l,1000000000l>>(&v12);
    v12 = std::chrono::operator-<long,std::ratio<1l,1000l>,long,std::ratio<1l,1000l>>(&v9, &v11);
    v2 = std::__shared_ptr_access<Logger,(__gnu_cxx::_Lock_policy)2,false,false>::operator->(v5 + 6208);
    v3 = std::chrono::duration<long,std::ratio<1l,1000l>>::count(&v12);
    std::to_string(v13, v3);
    std::operator+<char>(v14, "SLEEP: ", v13);
    Logger::log(v2, v14, 4LL);
    std::string::~string(v14);
    std::string::~string(v13);
    this = &v12;
    if ( std::chrono::duration<long,std::ratio<1l,1000l>>::count(&v12) > 0 )
    {
      this = &v12;
      std::this_thread::sleep_for<long,std::ratio<1l,1000l>>(&v12);
    }
    ++v6;
  }
  return v15 - __readfsqword(0x28u);
}

```

```cpp
unsigned __int64 __fastcall Cpu::execute(Cpu *this)
{
  __int64 v1; // rbx
  __int64 v2; // rbx
  _BYTE v4[32]; // [rsp+10h] [rbp-60h] BYREF
  _BYTE v5[40]; // [rsp+30h] [rbp-40h] BYREF
  unsigned __int64 v6; // [rsp+58h] [rbp-18h]

  v6 = __readfsqword(0x28u);
  v1 = std::__shared_ptr_access<Logger,(__gnu_cxx::_Lock_policy)2,false,false>::operator->(this + 40);
  std::to_string(v4, *(this + 12));
  std::operator+<char>(v5, "INST ", v4);
  Logger::log(v1, v5, 4LL);
  std::string::~string(v5);
  std::string::~string(v4);
  switch ( *(this + 12) )
  {
    case 0:
      Cpu::decode_0_instruction(this);
      break;
    case 1:
      Cpu::jump_to(this);
      break;
    case 2:
      Cpu::call_subroutine(this);
      break;
    case 3:
      Cpu::skip_next_instruction_eq(this);
      break;
    case 4:
      Cpu::skip_next_instruction_ne(this);
      break;
    case 5:
      Cpu::skip_next_instruction_vx_vy(this);
      break;
    case 6:
      Cpu::register_set(this);
      break;
    case 7:
      Cpu::add_reg_imm(this);
      break;
    case 8:
      Cpu::decode_8_instruction(this);
      break;
    case 9:
      Cpu::skip_next_instruction_vx_vy_ne(this);
      break;
    case 0xA:
      Cpu::set_index_register(this);
      break;
    case 0xB:
      Cpu::jump_with_v0(this);
      break;
    case 0xC:
      Cpu::generate_random_number(this);
      break;
    case 0xD:
      Cpu::draw_sprite(this);
      break;
    case 0xE:
      Cpu::decode_E_instruction(this);
      break;
    case 0xF:
      Cpu::decode_F_instruction(this);
      break;
    default:
      v2 = std::__shared_ptr_access<Logger,(__gnu_cxx::_Lock_policy)2,false,false>::operator->(this + 40);
      std::to_string(v4, *(this + 12));
      std::operator+<char>(v5, "IMPOSSIBLE INSTRUCTION", v4);
      Logger::log(v2, v5, 1LL);
      std::string::~string(v5);
      std::string::~string(v4);
      break;
  }
  return v6 - __readfsqword(0x28u);
}
```

you analyze easy instruction but when you will reach the case: 0xF

```cpp
unsigned __int64 __fastcall Cpu::decode_F_instruction(Cpu *this)
{
  int v1; // eax
  __int64 v2; // rbx
  _BYTE v4[32]; // [rsp+10h] [rbp-60h] BYREF
  _BYTE v5[40]; // [rsp+30h] [rbp-40h] BYREF
  unsigned __int64 v6; // [rsp+58h] [rbp-18h]

  v6 = __readfsqword(0x28u);
  v1 = *(this + 11);
  if ( v1 == 255 )
  {
    Cpu::superChipRendrer(this);
    return v6 - __readfsqword(0x28u);
  }
  if ( v1 == 101 )
  {
    Cpu::load_regs_from_memory(this);
    return v6 - __readfsqword(0x28u);
  }
  if ( *(this + 11) > 0x65u )
    goto LABEL_19;
  if ( *(this + 11) > 0x33u )
  {
    if ( v1 == 85 )
    {
      Cpu::load_memory_from_regs(this);
      return v6 - __readfsqword(0x28u);
    }
LABEL_19:
    v2 = std::__shared_ptr_access<Logger,(__gnu_cxx::_Lock_policy)2,false,false>::operator->(this + 40);
    std::to_string(v4, *(this + 11));
    std::operator+<char>(v5, "Instruction F with code ", v4);
    Logger::log(v2, v5, 1LL);
    std::string::~string(v5);
    std::string::~string(v4);
    return v6 - __readfsqword(0x28u);
  }
  if ( *(this + 11) < 7u )
    goto LABEL_19;
  switch ( *(this + 11) )
  {
    case 7u:
      Cpu::load_reg_with_delay_timer(this);
      break;
    case 0xAu:
      Cpu::wait_key_press(this);
      break;
    case 0x15u:
      Cpu::load_delay_timer_with_reg(this);
      break;
    case 0x18u:
      Cpu::load_sound_timer_with_reg(this);
      break;
    case 0x1Eu:
      Cpu::add_ireg_with_reg(this);
      break;
    case 0x29u:
      Cpu::load_font_from_vx(this);
      break;
    case 0x33u:
      Cpu::store_binary_code_decimal_representation(this);
      break;
    default:
      goto LABEL_19;
  }
  return v6 - __readfsqword(0x28u);
}
```

So If you have read the blog you know there is no such instruction which exists in chip emulator as 0xFxFF, the v1 == 255 is 0xff, the MSB of first byte was checked in the first
switch statement.
But its emulated in our chip8, and if we check this emulated function it is indeed doing the decryption using the the library functions.

```cpp

unsigned __int64 __fastcall Cpu::superChipRendrer(Cpu *this)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rax
  unsigned int v8; // r12d
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rax
  char v15; // [rsp+1Bh] [rbp-2F5h] BYREF
  int v16; // [rsp+1Ch] [rbp-2F4h] BYREF
  int i; // [rsp+20h] [rbp-2F0h]
  int v18; // [rsp+24h] [rbp-2ECh]
  __int64 v19; // [rsp+28h] [rbp-2E8h]
  _QWORD *v20; // [rsp+30h] [rbp-2E0h]
  int *v21; // [rsp+38h] [rbp-2D8h]
  int *v22; // [rsp+40h] [rbp-2D0h]
  char *v23; // [rsp+48h] [rbp-2C8h]
  _BYTE v24[32]; // [rsp+50h] [rbp-2C0h] BYREF
  _BYTE v25[32]; // [rsp+70h] [rbp-2A0h] BYREF
  _QWORD v26[4]; // [rsp+90h] [rbp-280h] BYREF
  _BYTE v27[32]; // [rsp+B0h] [rbp-260h] BYREF
  _BYTE v28[248]; // [rsp+D0h] [rbp-240h] BYREF
  __int64 v29; // [rsp+1C8h] [rbp-148h] BYREF
  __int64 v30; // [rsp+2D7h] [rbp-39h] BYREF
  char v31; // [rsp+2DFh] [rbp-31h]
  _BYTE v32[24]; // [rsp+2E0h] [rbp-30h] BYREF
  unsigned __int64 v33; // [rsp+2F8h] [rbp-18h]

  v33 = __readfsqword(0x28u);
  v20 = v26;
  std::string::basic_string<std::allocator<char>>(v28, &bytearray3, v26);
  Cpu::chat_toStr(v27, this, v28);
  std::string::~string(v28);
  Cpu::base64Decode(v24, this, &_3nc);
  v26[0] = std::vector<unsigned char>::begin(v24);
  v1 = __gnu_cxx::__normal_iterator<unsigned char *,std::vector<unsigned char>>::operator+(v26, 16LL);
  v2 = std::vector<unsigned char>::begin(v24);
  std::copy<__gnu_cxx::__normal_iterator<unsigned char *,std::vector<unsigned char>>,unsigned char *>(v2, v1, v32);
  v21 = &v16;
  v3 = std::vector<unsigned char>::end(v24);
  v26[0] = std::vector<unsigned char>::begin(v24);
  v4 = __gnu_cxx::__normal_iterator<unsigned char *,std::vector<unsigned char>>::operator+(v26, 16LL);
  std::vector<unsigned char>::vector<__gnu_cxx::__normal_iterator<unsigned char *,std::vector<unsigned char>>,void>(
    v25,
    v4,
    v3,
    &v16);
  v19 = EVP_CIPHER_CTX_new();
  v5 = std::string::data(v27);
  v6 = EVP_aes_256_cbc();
  if ( EVP_DecryptInit_ex(v19, v6, 0LL, v5, v32) != 1 )
    EVP_CIPHER_CTX_free(v19);
  v30 = 0x5E525E044D4B464CLL;
  v31 = 0;
  v22 = &v16;
  v7 = std::vector<unsigned char>::size(v25);
  std::vector<unsigned char>::vector(v26, v7, &v16);
  v8 = std::vector<unsigned char>::size(v25);
  v9 = std::vector<unsigned char>::data(v25);
  v10 = std::vector<unsigned char>::data(v26);
  if ( EVP_DecryptUpdate(v19, v10, &v16, v9, v8) != 1 )
    EVP_CIPHER_CTX_free(v19);
  v18 = v16;
  for ( i = 0; *(&v30 + i); ++i )
    *(&v30 + i) ^= 0x2Au;
  v11 = std::vector<unsigned char>::data(v26);
  if ( EVP_DecryptFinal_ex(v19, v11 + v16, &v16) != 1 )
    EVP_CIPHER_CTX_free(v19);
  v18 += v16;
  std::vector<unsigned char>::resize(v26, v18);
  EVP_CIPHER_CTX_free(v19);
  v23 = &v15;
  v12 = std::vector<unsigned char>::end(v26);
  v13 = std::vector<unsigned char>::begin(v26);
  std::string::basic_string<__gnu_cxx::__normal_iterator<unsigned char *,std::vector<unsigned char>>,void>(
    v28,
    v13,
    v12,
    &v15);
  std::string::operator=(&_3nc, v28);
  std::string::~string(v28);
  std::ofstream::basic_ofstream(v28, &v30, 4LL);
  std::ios::operator!(&v29);
  std::operator<<<char>(v28, &_3nc);
  std::ofstream::close(v28);
  std::ofstream::~ofstream(v28);
  std::vector<unsigned char>::~vector(v26);
  std::vector<unsigned char>::~vector(v25);
  std::vector<unsigned char>::~vector(v24);
  std::string::~string(v27);
  return v33 - __readfsqword(0x28u);
}

```

it is also opening a file, we can see the ofstream in this function, so it is decrypting our flag it self the \_3nc is the encrypted flag, and the key was copied into bytearray3 in cpu::cache()
So if we trigger this function we will get our flag.txt in our directory :)

The description is very clear that there is a flaw in cpu and you will get the flag in quad cycle, means it we have to trigger this function in 4 CPU cycles.

Well to do this To do this we can simply patch (in hexeditor or any tool of your choice) any of the given game to the opcodes fxff (1st cycle) repeat this patching 4 times.

```bash

Before patching (it can be any game)

00000000   6A 00 6B 04  6C 01 6D 00  6E 02 23 26  23 20 60 30  61 01 F0 15  F0 07 F1 18  j.k.l.m.n.#&# `0a.......
00000018   30 00 12 14  22 42 23 20  7D 01 23 20  60 08 E0 A1  23 0A 4A 00  12 3E A3 62  0..."B# }.# `...#.J..>.b
00000030   D8 91 79 01  D8 91 4F 01  12 F4 49 18  12 E4 22 B2  12 1E 4C 01  22 6C 4C 02  ..y...O...I..."...L."lL.
00000048   22 7A 4C 03  22 88 4C 04  22 96 4C 05  22 A4 A3 59  D6 72 44 00  00 EE A3 57  "zL.".L.".L."..Y.rD....W
00000060   D4 52 42 00  00 EE A3 5B  D2 32 00 EE  66 28 67 09  64 00 65 00  62 00 63 00  .RB....[.2..f(g.d.e.b.c.

```

```bash

After patching to FxFF where x can be any number/char it is not emulated dw

00000000   F1 FF F2 FF  F3 FF F4 FF  6E 02 23 26  23 20 60 30  61 01 F0 15  F0 07 F1 18  ........n.#&# `0a.......
00000018   30 00 12 14  22 42 23 20  7D 01 23 20  60 08 E0 A1  23 0A 4A 00  12 3E A3 62  0..."B# }.# `...#.J..>.b
00000030   D8 91 79 01  D8 91 4F 01  12 F4 49 18  12 E4 22 B2  12 1E 4C 01  22 6C 4C 02  ..y...O...I..."...L."lL.
00000048   22 7A 4C 03  22 88 4C 04  22 96 4C 05  22 A4 A3 59  D6 72 44 00  00 EE A3 57  "zL.".L.".L."..Y.rD....W
00000060   D4 52 42 00  00 EE A3 5B  D2 32 00 EE  66 28 67 09  64 00 65 00  62 00 63 00  .RB....[.2..f(g.d.e.b.c.

```

I replaced x with the number of cycle it will take for cpu :)
Save the game, and run the emulator you will get the flag.txt :p

Flag: `C00K3D{N0w_y0uMight_h4v3_an_1dea_H0w_3mulatorsWoRK}`

How different is the stripped one?, The opcodes are in the switch case statement, so still it can be recognized that the function is emulating 0xfxff
We can also jump directly to it by xrefs :p
